Thor - http://codeforces.com/contest/704/problem/B

[题目大意]

x轴上有N个点，初始点编号为s，终止点编号为e，任意两个点之间都有一条路径（费用之后描述），希望能够从点s，经过每一个点一次，最后到达点e。

点i到点j的基础费用为|x[i]-x[j]|。

从点i出发的额外费用为：从左侧出发为c[i], 从右侧触发为d[i]。
抵达于点j的额外费用为：从左侧抵达为a[i]，从右侧抵达为b[i]。

即：
如果i<j，则从点i到点j的总费用为|x[i]-x[j]|+d[i]+a[j]。
如果i>j，则从点i到点j的总费用为|x[i]-x[j]|+c[i]+b[j]。

[关键字]
动态规划、图、贪心

[大致思路]

费用示意：
a[i] ->     <- b[i]
         i
c[i] <-     -> d[i]    

因为做的时候直接看到了关键字，所以一开始以为会是个贪心引导的构造题，看了样例才发现不是。不过看到了dp就缩小了很多范围，期间也经过了一些弯路，最后确定为从左到右的dp。
思路雏形是不考虑s和e的话只有3种点，“（”，“-”，“）”，即连接该点的两条边是在左侧、在右侧还是都有。

一旦每个点的类型确定了，我们会发现额外费用部分已经确定，而基础费用部分无论怎么确定连线，也是固定的（这个证明应该挺直观的）。
基于这种设定，按照从左到右依次确定每个点的类型的话，会发现后效性仅和“当前延伸出的边数”有关（1个“（”意味着2条延伸出的边，1个“-”因为同时消耗1条，所以是0条，1个“）”意味-2条），为两点间距离乘以这个边数。

此时考虑s和e，s有两种类型“<-s”和“s->”，产生了方向上的区别，于是“当前延伸出的边数”需要分开计数，不妨将其中向左的记为j，将其中向右的记为j+k，在不考虑s和e的情况下，k始终是0。
于是有：
对于类型“<-s”，j--, k++
对于类型“s->”，k++
对于类型“->t”，k--
对于类型“t<-”，j++, k--
由于s和e均仅有一个，所以有j>=0, -1<=k<=1。

根据以上分析，我们可以定义状态f[i][j][k]，表示已经确定了1..i的类型，存在j条向左的延伸边，j+k条向右的延伸边的情况下，最小费用是多少。
初始状态需要根据点1的类型进行判断（也可以用f[0][0][0]，不过要处理一下连通性，以确保最后方案不是多个环+一条链）。
最终状态是f[n][0][0]。
状态转移方程可以参考后面的代码_(:з」∠)_就不重新写了。

总的来说，这题还是相当有意思的，挺好奇这道题是怎么出出来的。

[额外信息]
1. 交了7次
2. 前2次是调试信息没有删
3. 第3次是判断最左侧点类型是否为s或e时与0进行比较（应该为1）
4. 第4次是没有开long long
5. 第5次是开了long long之后空间炸了，于是改成滚动数组
6. 第6次是计算过程中爆了int，于是把中间参数也改成long long
7. 明明读题的时候注意到了long long有个坑，结果写的时候忘记了

[核心代码]
vector<vector<vector<long long> > > f(2, vector<vector<long long> >(n + 1, vector<long long>(3, -1)));
#define f(i, j, k) f[(i) % 2][(j)][(k) + 1]
f(1, s != 1, (s == 1) - (e == 1)) = (s != 1) * b[1] + (e != 1) * (d[1]);
for (int i = 1; i < n; i++) 
	for (int j = 0; j <= i; j++)
		for (int k = -1; k <= 1; k++) if (f(i, j, k) != -1) {
			if (j > 0 || j + k > 0) {
				long long cost = f(i, j, k) + 1LL * (j * 2 + k) * (x[i + 1] - x[i]);
				if (e == i + 1) {
					updateType1(cost + a[i + 1], f(i + 1, j, k - 1));
					updateType1(cost + b[i + 1], f(i + 1, j + 1, k - 1));
				}
				else if (s == i + 1) {
					updateType1(cost + c[i + 1], f(i + 1, j - 1, k + 1));
					updateType1(cost + d[i + 1], f(i + 1, j, k + 1));
				}
				else {
					if (j > 0) updateType1(cost + b[i + 1] + c[i + 1], f(i + 1, j, k));
					if (j + k > 0) updateType1(cost + a[i + 1] + d[i + 1], f(i + 1, j, k));
					if (j > 0 && j + k > 0) updateType1(cost + a[i + 1] + c[i + 1], f(i + 1, j - 1, k));
					updateType1(cost + b[i + 1] + d[i + 1], f(i + 1, j + 1, k));
				}
			}
			f(i, j, k) = -1;
		}
cout << f(n, 0, 0) << endl;