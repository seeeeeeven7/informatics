Thor - http://codeforces.com/contest/704/problem/A

[题目大意]

一部手机，N个应用，Q次操作：

类型1：第x个应用产生一条通知
类型2：阅读第x个应用的所有通知（可能会重复阅读）
类型3：阅读所有通知按时间顺序从前到后的前t条通知（可能会重复阅读）

每次操作后输出当前剩余的未读通知数。

[关键字]
暴力、数据结构、实现技巧

[做法1]

维护N个队列app，app[i]表示第i个应用产生的所有通知，具体指为该通知的编号（第几条产生）
另外维护一个数组nots，nots[i]表示每i条通知是那个应用产生的

对于类型1：维护app,nots和统计数量
对于类型2：维护app和统计数量
对于类型3：依次访问nots数组里没有被处理过的部分，对于第i条消息，检查app[nots[i]].front()和t的关系，来判断该消息是否已经被阅读，从而继续维护。

[做法2]

维护数组count, count[i]表示第i个应用的未读消息树，
维护数组read, read[i]表示上一次引用i的类型2操作发生时，总共有多少条信息(nots的长度)
维护数组nots，nots[i]表示每i条通知是那个应用产生的

对于类型1：维护count,nots和统计数量
对于类型2：维护count,read和统计数量
对于类型3：依次访问nots数组里没有被处理过的部分，对于第i条消息，检查read[nots[i]]和i（注意此处是i不是t），来判断该消息是否已经被阅读，从而继续维护。

[额外信息]
1. 做法1和做法2的时间复杂度一致，空间复杂度做法1占用较多。
2. 用stl会显著增加通过时间（1000+MS : 100+MS）
3. 做法2比较难彻底理解，特别判断中的i